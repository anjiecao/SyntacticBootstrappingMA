---
title: 'Syntactic Bootstrapping MA'
author: "Anjie Cao and Molly Lewis"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    number_sections: yes
    theme: paper
    toc: yes
    toc_float: no
subtitle: Supplementary Information
---

******
******

```{r setup, include = F}
# load packages
library(tidyverse)
library(knitr)
library(here)
library(metafor)
library(ggimage)
library(imager)
library(stringr)
library(glue)
library(heatmaply)
library(PublicationBias)
source(here("writeups/paper/scripts/model_print.R"))
source(here("writeups/paper/scripts/forest_plot_helper.R"))
source(here("writeups/paper/scripts/funnel_plot_helper.R"))
source(here("writeups/paper/scripts/predictor_plot_helper.R"))

opts_chunk$set(echo = F, message = F, warning = F, 
               error = F, cache = F, tidy = F, fig.height = 4.5)

theme_set(theme_classic())
options(shiny.sanitize.errors = FALSE)
```  

<a href="https://github.com/anjiecao/SyntacticBootstrapping" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm</style>

This document was created from an R markdown file. The repository for the project can be found [here](https://github.com/anjiecao/SyntacticBootstrapping). The data reported in the paper can be explored interactively at the [Metalab website](http://metalab.stanford.edu/).

```{r }
DATA_PATH <- here("data/processed/syntactic_bootstrapping_tidy_data.csv") 
RAW_DATA_PATH <- here("data/raw/syntactic_bootstrapping_raw_data.csv")

ma_data <- read_csv(DATA_PATH) %>% 
  mutate(presentation_type = presentation_type_collapsed)
ma_raw_data <- read_csv(RAW_DATA_PATH)
```

# Details of calculating effect size
UNDER CONSTRUCTION
https://mlewis.shinyapps.io/xtmem_SI/#section-effect-size-calculation

To standardize the effect size calculation, we converted some reported raw results to the proportion of correct responses. For looking time studies, when the paper only reported the raw looking time in seconds, we calculated the proportion of correct response by dividing the mean looking time toward the matching scene by the sum of looking time toward the matching scenes and non-matching scenes (i.e., excluding the look away time from the denominator). The raw standard deviations were also converted to the corresponding values by being divided by the sum.
```{r}

```


# Major Models excluding the imputed value
```{r}

```

#<!-- do we also have a random effect of condition? does including this influence the estimates at all? -->


# Sensitivity analysis

```{r}
ma_data_with_affirm <- ma_data %>%
  mutate(pvalue =  2 * (1 - pnorm( abs(d_calc / sqrt(d_var_calc)))),
         affirm =  (d_calc > 0) & (pvalue < 0.05))

affirm_model<- rma.mv(d_calc,  d_var_calc,  
                         random = ~ 1 | short_cite/same_infant/x_1, data=
          ma_data_with_affirm %>% filter(affirm == FALSE)) 

affirm_estimate <- as.numeric(affirm_model$b)

worst_case_estimate_print <- paste0(as.numeric(round(affirm_model$beta, 2)),
                                    " [",
                                    as.numeric(round(affirm_model$ci.lb, 2)),
                                    ", ",                                                                                                        as.numeric(round(affirm_model$ci.ub, 2)),
                                    "]")
 
all_model <- rma.mv(d_calc,  d_var_calc,  
                         random = ~ 1 | short_cite/same_infant/x_1, data=
          ma_data_with_affirm)
all_estimate <- as.numeric(all_model$b)

```

The plot below shows a modified funnel plot, or "significance funnel" where significant studies are shown in orange and non-significant studies are shown in grey. The x-axis shows effect size estimates, and the y-axis shows estimated standard error for each estimate. Studies lying on the grey line have a p-value of .05. The black diamond shows the meta-analytic effect size estimate for all studies; the grey diamond shows the meta-analytic effet size estimate for significant studies only (the "worst-case" publication scenario). Note that the worst case scenario appreciable attenuates the effect size estimate, but does not attentuate the point estimate to 0 (worst case estimate: `r worst_case_estimate_print`).



```{r}
significance_funnel(
  ma_data$d_calc,
  ma_data$d_var_calc,
  xmin = min(ma_data$d_calc),
  xmax = max(ma_data$d_calc),
  ymin = 0,
  ymax = max(sqrt(ma_data$d_var_calc)),
  xlab = "Point estimate",
  ylab = "Estimated standard error",
  favor.positive = TRUE,
  est.all = all_estimate,
  est.N = affirm_estimate,
  alpha.select = 0.05,
  plot.pooled = TRUE
)

```


# Heat Map {.tabset}

The heatmaps below showed the overlappings between moderators. Each cell corresponds to the co-occurrence between two moderator levels. Brighter colors indicate a higher frequency of co-occurrence, and darker colors indicate lower frequency. You can hover your mouse on the heatmap to see the corresponding value and combination of each cell. 


## Ordered by Row Average 
```{r fig.width=9.5, fig.height=9.5}
ALL_CATEGORICAL_VARS <- c("presentation_type",
                      #"agent_argument_type", "patient_argument_type", 
                     "stimuli_modality", "stimuli_actor", "character_identification",   "practice_phase", "test_mass_or_distributed", "transitive_event_type", "intransitive_event_type")


get_cross_counts <- function(args, df){
  var1 = args[[1]]
  var2 = args[[2]]
  
  if (var1 != var2){
  
  df %>%
    select_(var1, var2) %>%
    rename(v1 = var1, 
          v2 = var2) %>%
    count(v1, v2) %>%
    mutate(v1_long = glue("{var1}/{v1}"),
           v2_long = glue("{var2}/{v2}"))  %>%
    select(v1_long, v2_long, n) 

  }
}

all_pair_counts <- list(ALL_CATEGORICAL_VARS,
                        ALL_CATEGORICAL_VARS) %>%
  cross() %>%
  map_df(get_cross_counts, ma_data) %>%
  complete(v1_long, v2_long, fill = list(n = 0)) %>%
  filter(v1_long != v2_long)


  all_counts_wide <- all_pair_counts %>%
    pivot_wider(names_from = v2_long, values_from = n) 
  

  all_counts_wide_matrix <- all_counts_wide %>%
    select(-v1_long) %>%
    as.matrix()
  
  row.names(all_counts_wide_matrix) <-  as.character(all_counts_wide$v1_long)
  heatmaply(all_counts_wide_matrix,
            fontsize_row = 8,
            fontsize_col = 8)
```

## Ordered by groups        
```{r fig.width=9.5, fig.height=9.5}
ALL_VARS <- colnames(all_counts_wide_matrix)
ALL_VARS <- c("character_identification/yes", 
              "character_identification/no", 
              "practice_phase/yes", 
              "practice_phase/no", 
              "transitive_event_type/direct_caused_action",
              "transitive_event_type/indirect_caused_action", 
              "intransitive_event_type/one_action", 
              "intransitive_event_type/parallel_actions" , 
              "presentation_type/asynchronous", 
              "presentation_type/simultaneous", 
              "test_mass_or_distributed/mass", 
              "test_mass_or_distributed/distributed", 
              "stimuli_actor/person", 
              "stimuli_actor/non_person", 
              "stimuli_modality/video", 
              "stimuli_modality/animation"
              )

ordered_matrix <- all_counts_wide_matrix %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  slice(match(ALL_VARS, rowname)) %>% 
  column_to_rownames("rowname") %>% 
  select(all_of(ALL_VARS))

heatmaply(ordered_matrix,
            fontsize_row = 8,
            fontsize_col = 8,
           Rowv = NA, 
          Colv = NA)
```


# Additional Models: Methodological Moderators with Theoretical Moderators
## Methodological Moderators with Age
```{r}
age_method_m <- fit_method_model("mean_age", ma_data)
print_method_model(age_method_m) %>% kable()


```

## Methodological Moderators with Productive Vocabulary Size 
```{r}
vocab_method_m <- fit_method_model("productive_vocab_median", ma_data)
print_method_model(vocab_method_m) %>% kable()
```

## Methodological Moderators with Sentence Structure 
```{r}
sentence_structure_method_m <- fit_method_model("sentence_structure", ma_data)
print_method_model(sentence_structure_method_m) %>% kable()

```

## Methodological Moderators with Agent Argument Type
```{r}
argument_type_method_m <- fit_method_model("agent_argument_type", ma_data)
print_method_model(argument_type_method_m) %>% kable()
```




# Additional Moderators*
*The moderators' estimates are for the first level in the parenthesis. 
```{r include=FALSE}
ADDITIONAL_MODERATORS <- c("stimuli_modality", "stimuli_actor",  "transitive_event_type", "intransitive_event_type")
INTRANSITIVE <- c("patient_argument_type")
additional_main <- generate_moderator_df(ADDITIONAL_MODERATORS, ma_data)
intransitive <- generate_moderator_df(INTRANSITIVE, filter(ma_data, sentence_structure == "transitive"))
additional_main <- bind_rows(additional_main, intransitive) %>% 
  select(this_moderator, n, 
         estimate_print_full, z_print, p_print, 
         mod_estimate_print_full, mod_CI_print, mod_z_print, mod_p_print) %>% 
  mutate(
    intercept = estimate_print_full, 
    moderator = mod_estimate_print_full,
    intercept_z_val = gsub("= ","", z_print), 
    intercept_p_val = gsub("= ", "", p_print),
    mod_z_val = gsub("= ", "", mod_z_print),
    mod_p_val = gsub("= ", "", mod_p_print)
  )

```

## Patient argument type for transitive sentence 

In the main analysis, we presented the results of the model for the relationship between effect size and the agent argument type. We found that having nouns or pronouns int he agent argument does not significantly predict the effect size. Here, we presented a similar analysis of the influence of the patient argument type. Because by definition English intransitive sentences do not have patient argument, we focus on the subset of studies that used the transitive sentences ($N$ = `r filter(additional_main, this_moderator == "patient_argument_type")$n`)

```{r}

pretty_moderator_name <- function(s){
  new_s <- str_to_title(gsub("_", " ",s))
  return(new_s)
}

convert_pretty_print_table <- function(full_df, current_moderator){
  
  estimates <- full_df %>% 
    filter(this_moderator == current_moderator) %>% 
    pivot_longer(cols = c(intercept, moderator), names_to = "Parameter", values_to = "Estimate") %>% 
    select(Parameter, Estimate)
  
  z_val <- full_df %>% 
    filter(this_moderator == current_moderator) %>% 
    pivot_longer(cols = c(intercept_z_val, mod_z_val), names_to = "Parameter", values_to = "z value") %>% 
    select("z value")
  
  p_val <- full_df %>% 
    filter(this_moderator == current_moderator) %>% 
    pivot_longer(cols = c(intercept_p_val, mod_p_val), names_to = "Parameter", values_to = "p value") %>% 
    select("p value")
  
  all_df <- bind_cols(estimates, z_val, p_val) %>% 
    mutate(
      Parameter = case_when(
        Parameter == "moderator" ~ pretty_moderator_name(current_moderator),
        Parameter == "intercept" ~ "Intercept"
      )
    )
  
  return(all_df)
  
}


patient_argument_type_table <- convert_pretty_print_table(additional_main, "patient_argument_type") %>% 
  mutate(
    Parameter = case_when(
      Parameter == "Patient Argument Type" ~ "Patient Argument Type (Pronoun / Noun)",
      TRUE ~ Parameter
    )
  )

patient_argument_type_table %>% 
  kable() 
```



## Stimuli Modality (Video or Animation)

We found that the presentation modality of the stimuli was not a significant predictor of the effect size. In other words, studies that presented young children with animation clips had similar effect sizes as studies using video clips. The model statistics are shown below. Note that the stimuli modality and the stimuli actor levels had a lot of overlapping studies, so researchers should interpret this result with caution. 


```{r}
stimuli_argument_type_table <- convert_pretty_print_table(additional_main, "stimuli_modality") %>% 
  mutate(
    Parameter = case_when(
      Parameter == "Stimuli Modality" ~ "Stimuli Modality (Video / Animation)",
      TRUE ~ Parameter
    )
  )
stimuli_argument_type_table %>% 
  kable()
```


## Stimuli actors (Person or Non-person)
Similarly, we did not find an effect of stimuli actors. Studies with human actors as protagonists in the events had similar effect sizes as studies using puppets, human actors in animal suits, or using animated geometrical shapes. 

```{r}
stimuli_actor_type_table <- convert_pretty_print_table(additional_main, "stimuli_actor")  %>% 
  mutate(
    Parameter = case_when(
      Parameter == "Stimuli Actor" ~ "Stimuli Actor (Person / Non-person)",
      TRUE ~ Parameter
    )
  )
stimuli_actor_type_table %>% 
  kable()
```

## Type of event {.tabset}
Studies differed in the type of transitive events and intransitive events they presented. Previous studies have shown that young children's looking behaviors in Inter-modal Preferential Looking Paradigm were very sensitive to the subtle perceptual differences in the visual stimuli (Delle Luche, Durrant, Poltrock, & Floccia, 2015; Fernald, Zangl, Portillo, & Marchman, 2008). Therefore, we coded the types of events presented in the visual stimuli. There were two types of transitive events: direct causal action and indirect causal action. The former involved the agent directly acting on the patient and causing the patient to move. The latter involved a mean-end sequence leading to the caused action of the patient. For example, the agent may pull a band on the patient's waist and caused it to move. There were also two types of intransitive events used in the literature. One involved a single actor acting, such as jumping up and down. The other involved two actors presented without any causal action. 

Our model suggested that neither of the variables was predictive of the effect sizes. 



### Transitive Event: Direct causal action or Indirect causal action
```{r}
transitive_event_type_table <- convert_pretty_print_table(additional_main, "transitive_event_type")  %>% 
  mutate(
    Parameter = case_when(
      Parameter == "Transitive Event Type" ~ "Transitive Event Type (Indirect caused action / Direct caused action)",
      TRUE ~ Parameter
    )
  )


transitive_event_type_table %>% 
  kable()
```
### Intransitive Event: Single-actor or parallel actions
```{r}
intransitive_event_type_table <- convert_pretty_print_table(additional_main, "intransitive_event_type")  %>% 
  mutate(
    Parameter = case_when(
      Parameter == "Intransitive Event Type" ~ "Intransitive Event Type (Parallel actions / One action)",
      TRUE ~ Parameter
    )
  )

intransitive_event_type_table %>% 
  kable()
```


 





# Variability in visual stimuli as a function of age

There was some evidence for researchers adapting the level of visual complexity in the visual stimuli according to children's age. We collected the available visual stimuli from the papers and the supporting materials. Schematic illustrations of the visual stimuli were used when the actual screenshots were not provided. Screenshots of the text descriptions of the events were used when the visual stimuli were unavailable. Note that because some papers' publishers converted to the visual stimuli to black-and-white, we decided to grayscale all visual stimuli for easier visual comparison.  

It is easy to see in the plot that studies for particularly young children used significantly simpler visual stimuli. This adaptation might be partly responsible for the lack of age effect observed in our samples.  


```{r}

ma_data <- read_csv(DATA_PATH) %>% 
  mutate(row_id = 1:n()) %>%
  rowwise() %>%
  mutate(stim_path = paste(unique_id, expt_num, sentence_structure,sep = "_"),
         stim_path = paste0(here("resources/stimuli_forplot/"), stim_path, ".png"),
         stim_path = str_replace(stim_path, "yuan2012_3_", "yuan2012_3simple_"))


age_model <- rma.mv(d_calc ~ mean_age, V = d_var_calc,
                      random = ~ 1 | short_cite/same_infant/row_id,
                      method = "REML",
                      data = ma_data )


```

```{r, fig.width = 10, fig.height = 8}
ma_data_with_predictions <- predict(age_model) %>%
  as.data.frame() %>%
  bind_cols(ma_data) %>% 
  mutate(
    mean_age_months = mean_age / 30.44
  )

ggplot(ma_data_with_predictions, aes(x = mean_age_months, y = d_calc)) +
  geom_image(aes(image = stim_path)) +
  geom_smooth(method = "lm") +
  #geom_smooth(method = "lm", data = ma_data_with_predictions, aes(x = mean_age, y = pred)) +
  scale_x_continuous(breaks = seq(0, 48, by = 12), limits = c(9, 48)) +
  geom_hline(aes(yintercept = 0), color = "black", linetype = "dashed") +
  ylab("Effect Size (d)") +
  xlab("Mean age (months)")
```



**References**


Delle Luche, C., Durrant, S., Poltrock, S., & Floccia, C. (2015). A methodological investigation of the Intermodal Preferential Looking paradigm: Methods of analyses, picture selection and data rejection criteria. Infant Behavior and Development, 40, 151-172

Fernald, A., Zangl, R., Portillo, A. L., & Marchman, V. A. (2008). Looking while listening: Using eye movements to monitor spoken language. Developmental psycholinguistics: On-line methods in childrenâ€™s language processing, 44, 97.


